\documentclass[a4paper,10pt]{article}

% This bunch of macros grew to that size in a couple of years,
% some parts are even decades old, so be aware of the risks of diving in!

\usepackage{palatino}
%\usepackage{lmodern}

% Narrow the margins a bit to fit in the code
\usepackage[margin=1.2in]{geometry}
\usepackage{amsmath, amsthm,amsfonts,amssymb}
\usepackage{graphicx}
\usepackage{fixltx2e}
\usepackage{listings}
\usepackage{algorithm}

\usepackage{hyperref}
\usepackage{longtable}
\usepackage{siunitx}
\usepackage{graphicx}

\usepackage{float}
% pseudocode
\usepackage[end]{algpseudocode}
\newcommand*\Let[2]{\State #1 $\gets$ #2}
\algrenewcommand\alglinenumber[1]{{\sf\scriptsize#1}}
\algrenewcommand\algorithmicrequire{\textbf{Input:}}
\algrenewcommand\algorithmicensure{\textbf{Output:}}

\makeatletter
\let\OldStatex\Statex
\renewcommand{\Statex}[1][3]{%
  \setlength\@tempdima{\algorithmicindent}%
  \OldStatex\hskip\dimexpr#1\@tempdima\relax}
\makeatother

\algnewcommand\algorithmicblackcomment[1]{\hfill\(\blacktriangleright\) #1}
\algnewcommand{\CommentMulti}[1]{ \(\blacktriangleright\) #1}
\makeatletter
\algnewcommand{\CommentInlineMulti}[1]{\Statex[\theALG@nested] \(\triangleright\) #1}

% "algorithmic" without "algorithm" lacks all of the horizontal lines
% The top lines are in the  "captionof" redefinition below and the trailing
% line is here
\algrenewcommand\ALG@endalgorithmic{\Statex[-1]\hrulefill}

\usepackage{xpatch}
% too many fractions in the algorithms
% TODO: do it individually per case
\xpatchcmd{\algorithmic}{\itemsep\z@}{\itemsep=.25ex}{}{}
\makeatother


% shamelessly stolen from http://tex.stackexchange.com/questions/53357/switch-cases-in-algorithmic
% New definitions
\algnewcommand\algorithmicswitch{\textbf{switch}}
\algnewcommand\algorithmiccase{\textbf{case}}
\algnewcommand\algorithmicdefault{\textbf{default}}

\newcommand{\longsub}[1]{\text{\textit{\scriptsize{#1}}}}
\newcommand{\RETURN}{\State \textbf{return} }
\newcommand{\Break}{\State \textbf{break} }
\newcommand{\Continue}{\State \textbf{break} }

% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicdo}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algdef{SE}[DEFAULT]{Default}{EndDefault}[1]{\algorithmicdefault\ #1}{\algorithmicend\ \algorithmicdefault}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%

\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}


\makeatletter
\def\hrulefillthick{\leavevmode\leaders\hrule height .85pt\hfill\kern\z@}
\makeatother
% shamelessly stolen from http://tex.stackexchange.com/questions/33866/algorithm-tag-and-page-break
\usepackage[font=small,labelfont=bf,width=.8\linewidth]{caption}
\DeclareCaptionFormat{algor}{%
  \hrulefillthick\par\offinterlineskip\vskip2pt%
     \textbf{#1#2}#3\offinterlineskip\hrulefill}
\DeclareCaptionStyle{algori}{singlelinecheck=off,format=algor,labelsep=space}
\captionsetup[algorithm]{style=algori}
%Still necessary?
\MakeRobust{\Call}

% http://tex.stackexchange.com/questions/77996/how-to-show-a-hint-when-lstlisting-is-breaking-page
\usepackage[framemethod=tikz]{mdframed}
% define the frame style for the listing:
\mdfdefinestyle{note}
  {
    hidealllines = true,
    skipabove    = .5\baselineskip,
    skipbelow    = .5\baselineskip,
    singleextra  = {},
    firstextra   = {
      \node[below right,overlay,align=center,font=\continuingfont]
        at (O) {\continuingtext};
    },
    secondextra  = {
      \node[above right,overlay,align=center,font=\continuingfont]
        at (O |- P) {\continuedtext};
    },
    middleextra  = {
      \node[below right,overlay,align=center,font=\continuingfont]
        at (O) {\continuingtext};
      \node[above right,overlay,align=center,font=\continuingfont]
        at (O |- P) {\continuedtext};
    }
  }
\newcommand*\continuingfont{\footnotesize\itshape}
\newcommand*\continuingtext{\hspace{2em}Listing continues on next page}
\newcommand*\continuedtext{\hspace{2em}Continuing from last page}
% the trick with mdframed writes over the footnote-line,
% this lowers the footnote
\setlength{\skip\footins}{5ex}

\ifpdf
\pdfcompresslevel=9
\pdfinfo{
   /Title      (LibTomMath's Algorithms: Lars Helmstr√∂m's Barret\_todecimal)
   /Author     (Editor: Christoph Zurnieden)
   /Keywords   (arbitrary-precision algorithm libtommath libtom)
}
\fi


\providecommand{\abs}[1]{\left\lvert#1\right\rvert}
\providecommand{\floor}[1]{\left\lfloor#1\right\rfloor}
\providecommand{\ceil}[1]{\left\lceil#1\right\rceil}

\DeclareMathOperator{\AND}{\wedge}
\DeclareMathOperator{\OR}{\vee}
\DeclareMathOperator{\sgn}{sgn}
\DeclareMathOperator{\flog}{flog}

% don't forget to add an empty statement {} after that command to get a space
% I did not want to add another package to this already very heavy prelude
% but you can include the package "xspace" and change the macro to
% \newcommand{\nthroot}{$n^{\text{\tiny th}}$-root\xspace}
% some say that xspace produces more problems than it solves, vid.:
% https://tex.stackexchange.com/questions/86565/drawbacks-of-xspace
% where you'll find out that its own creator does not recommend it.
\newcommand{\nthroot}{$n^{\text{\tiny th}}$-root}

\newcommand{\RaiseNum}[2]{\raisebox{#1}{$\scriptstyle #2$}}

% wonder if I'll ever need it
% C&P from the amsthm documentation
\theoremstyle{plain} % is said to be the default
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}[thm]{Lemma}
\newtheorem{prop}[thm]{Proposition}

\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{conj}{Conjecture}[section]
\newtheorem{exmp}{Example}[section]

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{note}{Note}
\newtheorem{case}{Case}

% to get the notes a counter (lacks internationalization)
%\newcounter{notice}
%\newenvironment{notice}{
%\stepcounter{notice}
%\par\bigskip\noindent{\bfseries Note \arabic{notice}}
%\par\medskip}{\par\medskip}

% shamelessly stolen from https://tex.stackexchange.com/a/94466
% still lacks internationalization
\global\mdfdefinestyle{notice}{%
linecolor=gray,linewidth=1pt,%
leftmargin=1cm,rightmargin=1cm,
}
\newenvironment{fnotice}[1]{%
\mdfsetup{%
frametitle={\colorbox{white}{\,#1\,}},
%frametitle={\tikz\node[fill=white,rectangle,inner sep=0pt,outer sep=0pt]{#1};},
frametitleaboveskip=-\ht\strutbox,
%frametitleaboveskip=-0.5\ht\strutbox,
frametitlealignment=\raggedright
}%
\begin{mdframed}[style=notice]
}{\end{mdframed}}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{parigp}{
  alsoletter={\\},
  keywords={ for, forcomposite, fordiv, fordivfactored, forell, forfactored, forpart,%
             forperm, forprime, forsquarefree, forstep, forsubgroup, forsubset,%
             forvec, if, iferr, next, return, until, while, local, alias, allocatemem,%
             apply, call, default, extern, externstr, fold, getabstime, getenv,%
             getheap, getrand, getstack, gettime, getwalltime, global, inline, input,%
             localbitprec, localprec, print, print1, printf, printp, printsep,%
             printsep1, printtex, quit, read, readstr, readvec, self, setrand,%
             system, type, uninline, version, write, write1, writebin, writetex},
  keywordstyle=\bfseries,
  morekeywords={[2]{log, floor, ceil,gcd, lcm,sqrt, sqrtn,sqrtint,%
              sin,cos,tan,asin,acos,atan,sinh,cosh,tanh, asinh,acosh,atanh,%
              gamma,lngamma,psi,dilog,%
              % own functions
              flog2, newton, halley, bisection}},
  keywordstyle={[2]{\color{darkgray}\bfseries}},
  sensitive=false,
  comment=[l]{\\\\},
  commentstyle=\ttfamily,
  stringstyle=\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\lstdefinestyle{code}{
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   xleftmargin=.2\textwidth, xrightmargin=.2\textwidth,
   frame=lines
%   texcl= true
}

\lstdefinestyle{widercode}{
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   tabsize=2,
   breaklines=true,
   showtabs=false,
   xleftmargin=.05\textwidth, xrightmargin=.05\textwidth,
   frame=lines
}

\lstnewenvironment{pblisting}[1]
  {%
    \lstset{style=widercode,#1}%
    \mdframed[style=note]%
  }
  {%
    \endmdframed
  }
% to get subsubsection numbered, too
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}

% Boxes with the gray background
% shamelessly stolen from https://tex.stackexchange.com/a/7545
\usepackage{calc}
\newlength{\DepthReference}
\settodepth{\DepthReference}{g}
\newlength{\HeightReference}
\settoheight{\HeightReference}{T}
\newlength{\Width}
\newcommand{\newcolorbox}[2][gray!30] {%
  \settowidth{\Width}{#2}%
  \setlength{\fboxsep}{.9pt}%
  \fcolorbox{black}{#1}{%
    \raisebox{-\DepthReference} {%
      \parbox[b][\HeightReference+\DepthReference][c]{\Width}{\centering#2}%
    }%
  }%
}
\setlength{\fboxsep}{1pt}
%no, a framed ox with grey background is just too much here
%\newcommand*{\ttchar}[1]{\newcolorbox{\texttt{\strut#1}}}
\newcommand*{\ttchar}[1]{\texttt{\textbf{\strut#1}}}
\newcommand*{\smalltt}[1]{{\small\texttt{#1}}}
% tried several alternatives but a simple boldface seems to do it
\newcommand{\List}[1]{\mathbf{#1}}


\makeatletter
% Idea shamlessly stolen from Stephan Lehmke in
% https://tex.stackexchange.com/a/53716
\newcommand\circled
{%
  \mathpalette\@circled
}
\newcommand\@circled[2]
{%
  \mathbin%
  {%
    \ooalign{\hidewidth$#1#2$\hidewidth\crcr$#1\bigcirc$}%
  }%
}
\newcommand{\odiv}{\circled{\div}}
\makeatother

\sisetup{output-exponent-marker=\ensuremath{\mathrm{e}}}

\begin{document}
\title{LibTomMath's Algorithms: Lars Helmstr\"om's Barret\_todecimal}
\author{Current editor: Christoph Zurnieden\\
        \small{\texttt{$<$czurnieden@gmx.de$>$}}}
\date{Last change: \today}
\maketitle

%\tableofcontents
% Courier because Computer Modern has no boldface
\renewcommand{\ttdefault}{pcr}

\begin{abstract}
This artikel describes the algorithm behind the function \smalltt{Barret\_todecimal} in Lars Helmstr\"om's post to the TCL list\footnote{Available online at: \url{https://sourceforge.net/p/tcl/mailman/message/31972670/}}.
\end{abstract}

\section{Pseudocode}
\subsection{Setup}

The setup does nothing more than to check the input, compute the reciprocals and fill the cache with them.

% TODO: no minipage enclosure to reduce width, it is put on the next page if it is in one.
\begin{center}
  \captionof{algorithm}{mp\_get\_str\label{alg:mpgetstr}}
  \begin{algorithmic}[1]
    \Require{$a > 0$, big--integer; $b$, a buffer of size $\floor{\log(a)/\log(r)} + 1$; $2 \le r \le 64$ the radix}
    \Ensure{$b$ filled with the value of $a$ converted to a string with radix $r$}
    \Function{mp\_get\_str}{$a$}
      \If{$a < C_{\textnormal{\textit{cut--off}}}$}\Comment{Exact value of $C_{\textnormal{\textit{cut--off}}}$ depends on individual hardware}
         \State\Call{mp\_get\_str\_naive}{$a,b,r$}
      \EndIf
      \CommentInlineMulti{Here $t$ is a table with the start--values. Examples in table \ref{tab:startvalues}}
      \Let{$n$}{$t_n$}
      \Let{$M$}{$t_M$}
      \CommentInlineMulti{If the unmodified values of the table \ref{tab:startvalues} are used, $s = 40$ for all $t_n$}
      \Let{$s$}{$t_s$}
      \CommentInlineMulti{Here $\flog_2(x) = \floor{\log_2(x)}$ for simplicity}
      \Let{$c$}{$\flog_2\left(\floor{\frac{\flog_2\left(a\right)}{2\flog_2\left(n\right)}}\right)$}%
      \Comment{$n^{2^c} < a$, number of squarings such that $\log_2(n) \approx \log_2(a)/2$}
      \CommentInlineMulti{The lists $x^\ell$ need to be able to hold $c$ big--integers each.}
      \Let{$\List{n}_0$}{$n$}
      \Let{$\List{s}_0$}{$s$}
      \Let{$\List{m}_0$}{$\ceil{M/2^\gamma}$}

      \Let{$\rho$}{$1$}
      \While{$\rho < c$}
        \Let{$M$}{$\displaystyle{\floor{\left(2M^2-\floor{\frac{nM^4}{2^{2\left(s+\gamma\right)}}}\right)\frac{1}{2^\gamma}}+1}$}
        \Let{$m^\ell_\rho$}{$M$}
        \Let{$\rho$}{$\rho + 1$}
        \Let{$M$}{$2^\gamma M$}
      \EndWhile
      \State \Call{mp\_get\_str\_recursion}{$a, r, \List{n}, \List{s}, \List{m}, \rho - 1, 1, b$}
    \EndFunction
  \end{algorithmic}
\end{center}


\begin{center}
\begin{longtable}{r r r r c | r r r r c}
\multicolumn{1}{r}{$\mathbf{b}$}&
\multicolumn{1}{r}{$\mathbf{k}$}&
\multicolumn{1}{r}{$\mathbf{\gamma}$}&
\multicolumn{1}{r}{$\mathbf{n = b^k}$}&
\multicolumn{1}{c}{$\mathbf{M = \ceil{\ceil{2^{s+\gamma}/n}/2^\gamma}}$}&
\multicolumn{1}{r}{$\mathbf{b}$}&
\multicolumn{1}{r}{$\mathbf{k}$}&
\multicolumn{1}{r}{$\mathbf{\gamma}$}&
\multicolumn{1}{r}{$\mathbf{n = b^k}$}&
\multicolumn{1}{c}{$\mathbf{M = \ceil{\ceil{2^{s+\gamma}/n}/2^\gamma}}$}\\
\endfirsthead
%
\multicolumn{1}{r}{$\mathbf{b}$}&
\multicolumn{1}{r}{$\mathbf{k}$}&
\multicolumn{1}{r}{$\mathbf{\gamma}$}&
\multicolumn{1}{r}{$\mathbf{n = b^k}$}&
\multicolumn{1}{c}{$\mathbf{M = \ceil{\ceil{2^{s+\gamma}/n}/2^\gamma}}$}&
\multicolumn{1}{r}{$\mathbf{b}$}&
\multicolumn{1}{r}{$\mathbf{k}$}&
\multicolumn{1}{r}{$\mathbf{\gamma}$}&
\multicolumn{1}{r}{$\mathbf{n = b^k}$}&
\multicolumn{1}{c}{$\mathbf{M = \ceil{\ceil{2^{s+\gamma}/n}/2^\gamma}}$}\\
\endhead
% To get a bit more "headroom"
\rule{0pt}{1ex}\\
\multicolumn{6}{c}{{\footnotesize{\textit{Continued on next page}}}} \\
\endfoot
\endlastfoot
2  & 20 & 0 & 1048576 & 1048576  &  33 & 3  & 3 & 35937   & 30595532 \\
3  & 12 & 3 & 531441  & 2068926  &  34 & 3  & 5 & 39304   & 27974548 \\
4  & 10 & 0 & 1048576 & 1048576  &  35 & 3  & 4 & 42875   & 25644587 \\
5  & 8  & 3 & 390625  & 2814750  &  36 & 3  & 4 & 46656   & 23566351 \\
6  & 7  & 5 & 279936  & 3927726  &  37 & 3  & 5 & 50653   & 21706743 \\
7  & 7  & 5 & 823543  & 1335100  &  38 & 3  & 4 & 54872   & 20037754 \\
8  & 6  & 0 & 262144  & 4194304  &  39 & 3  & 6 & 59319   & 18535573 \\
9  & 6  & 3 & 531441  & 2068926  &  40 & 3  & 4 & 64000   & 17179870 \\
10 & 6  & 3 & 1000000 & 1099512  &  41 & 3  & 4 & 68921   & 15953217 \\
11 & 5  & 4 & 161051  & 6827103  &  42 & 3  & 5 & 74088   & 14840617 \\
12 & 5  & 4 & 248832  & 4418691  &  43 & 3  & 5 & 79507   & 13829118 \\
13 & 5  & 4 & 371293  & 2961305  &  44 & 3  & 4 & 85184   & 12907490\\
14 & 5  & 4 & 537824  & 2044371  &  45 & 3  & 5 & 91125   & 12065972 \\
15 & 5  & 3 & 759375  & 1447917  &  46 & 3  & 5 & 97336   & 11296043 \\
16 & 5  & 0 & 1048576 & 1048576  &  47 & 3  & 5 & 103823  & 10590251 \\
17 & 4  & 8 & 83521   & 13164494 &  48 & 3  & 4 & 110592  & 9942054  \\
18 & 4  & 3 & 104976  & 10473934 &  49 & 3  & 6 & 117649  & 9345695  \\
19 & 4  & 5 & 130321  & 8436949  &  50 & 3  & 5 & 125000  & 8796094  \\
20 & 4  & 5 & 160000  & 6871948  &  51 & 3  & 4 & 132651  & 8288755  \\
21 & 4  & 5 & 194481  & 5653569  &  52 & 3  & 3 & 140608  & 7819695  \\
22 & 4  & 3 & 234256  & 4693633  &  53 & 3  & 4 & 148877  & 7385370  \\
23 & 4  & 4 & 279841  & 3929059  &  54 & 3  & 4 & 157464  & 6982623  \\
24 & 4  & 6 & 331776  & 3314018  &  55 & 3  & 4 & 166375  & 6608635  \\
25 & 4  & 3 & 390625  & 2814750  &  56 & 3  & 4 & 175616  & 6260886  \\
26 & 4  & 5 & 456976  & 2406060  &  57 & 3  & 6 & 185193  & 5937113  \\
27 & 4  & 3 & 531441  & 2068926  &  58 & 3  & 4 & 195112  & 5635285  \\
28 & 4  & 4 & 614656  & 1788825  &  59 & 3  & 5 & 205379  & 5353574  \\
29 & 4  & 4 & 707281  & 1554562  &  60 & 3  & 5 & 216000  & 5090332  \\
30 & 4  & 5 & 810000  & 1357422  &  61 & 3  & 4 & 226981  & 4844070  \\
31 & 4  & 3 & 923521  & 1190565  &  62 & 3  & 4 & 238328  & 4613439  \\
32 & 4  & 0 & 1048576 & 1048576  &  63 & 3  & 4 & 250047  & 4397220 \\
   &    &   &         &          &  64 & 3  & 0 & 262144  & 4194304
\end{longtable}
\captionof{table}{Start--values with $s = 40$. Corrector $\gamma$ valid for up to $n^{2^{22}}$}\label{tab:startvalues}
\end{center}

\section{Computing the Reciprocals}

The reciprocals are the values of the sequence
$\ceil{\left(2^s/n\right)^{\left(2^k\right)}}  =  \ceil{\left(2^{2^ks}\right)/n^{\left(2^k\right)}}$
(with $k = \{0,1,2,3,\dots\}$, $s, n$ as described above). We cannot simply square if $2^s \nmid n$ and hence $\ceil{\left(2^s/n\right)}^{\left(2^k\right)} \not= \ceil{\left(2^s/n\right)^{\left(2^k\right)}}$ but we can use one round of Newton-Raphson to overcome this inconvenient obstacle.

\begin{equation}
x_{n+1} = x_n\left(2 - Dx_n\right) = 2x_n - Dx_n^2
\end{equation}

By substituting $x_n = \ceil{2^s/n}^2$ and\footnote{Here $\odiv$ stands for ``use truncating division (rounding to next integer in direction of zero) later in the algebraic transformations because truncating division is all we have in big--integer land''} $D = \left(n \odiv 2^s\right)^2$ we get

\begin{equation}\label{eq:newtonraphson01}
M = 2\ceil{2^s/n}^2 - \floor{\frac{\ceil{2^s/n}^4n^2}{2^{2s}}}
\end{equation}

If $n$ is not of the form $n = 2^j$, that is not a power of two $2^j \nmid n$ and the small adjustment $\gamma$ is needed.
\begin{equation}\label{eq:newtonraphson02}
M = 2\ceil{2^{s+\gamma}/n}^2 - \floor{\frac{\ceil{2^{s+\gamma}/n}^4n^2}{2^{2\left(s+\gamma\right)}}}
\end{equation}
See table \ref{tab:startvalues} for the exact values of $\gamma$.


\subsection{Recursion}
The actual working horse is this recursively called function.
\begin{center}
\begin{minipage}{.9\linewidth}
  \captionof{algorithm}{mp\_get\_str\_recursion\label{alg:mpgetstrrecursion}}
  \begin{algorithmic}[1]
    \Require{$a > 0$, big-integer, $r, \List{n}, \List{s}, \List{m}, \rho, L, b$, from mp\_get\_str}
    \Ensure{$b$ filled with the value of $a$ converted to  a string with radix $r$}
    \Function{mp\_get\_str\_recursion}{$a,\List{n}, \List{s}, \List{m}, \rho, L, b$}
    \If{$\rho < 0$}
      \Let{$b$}{$b^\frown a$}\Comment{Convert $a$ to a string with radix $r$ and add to $b$. See text for details}
      \RETURN
    \Else
      \Let{$q$}{$ \floor{\left(a\cdot \List{m}_\rho\right) / 2^{\left(\List{s}_\rho\right)}}$}\Comment{Quotient}
      \Let{$r$}{$ a - \List{n}_\rho \cdot q$}\Comment{Approximate remainder}
      \If{$r < 0$}
        \Let{$q$}{$q - 1$}
        \Let{$r$}{$r + \List{n}_\rho$}\Comment{Exact remainder}
      \EndIf
      \Let{$\rho$}{$\rho + 1$}
      \If{$\left(L = 1\right) \AND \left(q = 0\right) $}
        \State \Call{mp\_get\_str\_recursion}{$r,\List{n}, \List{s}, \List{m}, \rho, 1, b$}
      \Else
        \State \Call{mp\_get\_str\_recursion}{$q,\List{n}, \List{s}, \List{m}, \rho, L, b$}
        \State \Call{mp\_get\_str\_recursion}{$r,\List{n}, \List{s}, \List{m}, \rho, 0, b$}
      \EndIf
    \EndIf
    \EndFunction
  \end{algorithmic}
 \end{minipage}
\end{center}


If the chunk is small enough we can build that part of the output. The number of digits is in column $k$ in table \ref{tab:startvalues}. This is also a place where a bit of optimization can take place because the number of digits in the leafs is very small.

\subsubsection{Larger Leafs}
The algorithm as it is now goes to the very end of the recursion until the actual number conversion is done. The 
amount of converted digits is very small down there, just the number of digits in $n^1-1$.
To get more digits we need to stop at an earlier stage $\rho > 0$ of the recursion to do the conversion instead of $
\rho = 0$. The maximum number of digits needed for radix $r$ is
\begin{equation}
\ceil{\log_r\left(n^{\left(2^k\right)}-1\right)}\quad\text{with}\quad n = r^k
\end{equation}

\begin{center}
\begin{minipage}{.9\linewidth}
  \captionof{algorithm}{to\_string\label{alg:tostring}}
  \begin{algorithmic}[1]
    \Require{$a$, big--integer, $b$, buffer, $r$, $k$, $\rho$, $L$, bool (is left?)}
    \Ensure{$b$ filled with the value of $a$ converted to base $r$}
    \Function{to\_string}{$a$, $b$, $r$, $k$, $\rho$, $L$}
    \Let{$K$}{$k + 2^\rho - 1$}\Comment{Cut--off at $\rho=5$ on the authors machine.}
    \Let{$S$}{A temporary buffer of size $K$ (or use $b$ directly)}
    \Let{$(S_0,\dots ,S_K)$}{$48$} \Comment{Fill the whole buffer with the ASCII digit zero (\smalltt{0x30})}
    \Let{$i$}{$0$}
    \While{$a \not= 0$}
       \Let{$q$}{$\floor{\frac{a}{r}}$} \Comment{Big--integer single digit division}
       \Let{$d$}{$a - \left(q \cdot r\right)$}
       \Let{$c$}{$T_d$}\Comment{$T$ is a table mapping $d$ to a character}
       \Let{$S_{K-i}$}{$c$}\Comment{Fill buffer $S$ from the end}
       \Let{$i$}{$i + 1$}
       \Let{$a$}{$q$}
    \EndWhile
    % if !left AND (K-i) != 0 than  
    \EndFunction
  \end{algorithmic}
\end{minipage}
\end{center}

\subsubsection{Converting Radices that are Powers of Two}
The radices $2$, $4$, $8$, $16$, $32$, and $64$ can be converted in the loop in in algorithm \ref{alg:tostring} without any big--integer division, by masking of a sliding window of the size of the radix. Two limbs are needed if \smalltt{MP\_DIGIT\_BIT} is not a power of two, just one otherwise.

\begin{center}
\begin{minipage}{.9\linewidth}
  \captionof{algorithm}{to\_string\label{alg:tostringpo2}}
  \begin{algorithmic}[1]
    \Require{$a$, big--integer, $b$, buffer, $r = 2^j$, $k$, $\rho$, $L$, bool (is left?)}
    \Ensure{$b$ filled with the value of $a$ converted to base $r$}
    \Function{to\_string}{$a$, $b$, $r$, $k$, $\rho$, $L$}
    \Let{$K$}{$k + 2^\rho - 1$}\Comment{Cut--off at $\rho=5$ on the authors machine.}
    \Let{$S$}{A temporary buffer of size $K$ (or use $b$ directly)}
    \Let{$S_0,\dots ,S_K$}{$48$} \Comment{Fill the whole buffer with the ASCII digit zero, \smalltt{0x30}}
    \Let{$i$}{$0$}
    % for i = 0; i < a->used;i++ 
    %    take limb a->dp[i]
    %    if j bits are left in a->dp[i]
    %       mask of j bits and map that number to a character, append it to the temp.-string
    %    else
    %       grab the rest of the bits from a->dp[i+1]
    %       If there is no a->dp[i+1] ->break
    % endfor
    \While{$a \not= 0$}
       \Let{$q$}{$\floor{\frac{a}{r}}$} \Comment{Big--integer single digit division}
       \Let{$d$}{$a - \left(q \cdot r\right)$}
       \Let{$c$}{$T_d$}\Comment{$T$ is a table mapping $d$ to a character}
       \Let{$S_{K-i}$}{$c$}\Comment{Fill buffer $S$ from the end}
       \Let{$i$}{$i + 1$}
       \Let{$a$}{$q$}
    \EndWhile
    % if !left AND (K-i) != 0 than  
    \EndFunction
  \end{algorithmic}
\end{minipage}
\end{center}


\section{Convert a decimal string to a big integer}
The \smalltt{mp\_from\_decimal} is a much less complicated method. For simplicity only the recursive algorithm is given here.

\begin{center}
\begin{minipage}{.9\linewidth}
  \captionof{algorithm}{from\_decimal\label{alg:fromdecimal}}
  \begin{algorithmic}[1]
    \Require{$a$, big--integer, $b_{10}$, decimal string}
    \Ensure{$a$ filled with the value of $b_{10}$ converted from a decimal number}
    \Function{from\_decimal}{$a$}
    \Let{$\ell$}{$\#b_{10}$} \Comment{Number of bytes (characters) in the string}
    \If{The first character in $b_{10}$ is a minus--sign}
       \Let{$\ell$}{$\ell - 1$}
       \If{$\ell = 0$} \Comment{No digits beside the minus--sign}
          \RETURN {$\quad$error}
       \EndIf
       \Let{$a$}{$-a$}
       \State{Strip the byte for the character representing the sign from $b_{10}$}
    \EndIf
    \If{$\ell < C$}\Comment{$C$ is a (tunable) cut--off value. $C = 100$ seems reasonable.}
      \Let{$a$}{$b_{10} \to b_\beta$}\Comment{Convert the decimal number in $b$ to the bigint $a$.}
    \Else
      \State \Call{from\_decimal\_recursion}{$a$, $b_{10}$, $0$, $\ell$}
    \EndIf
    \EndFunction
  \end{algorithmic}
\end{minipage}
\end{center}

The recursion itself is as straight forward as a recursion can be.

\begin{center}
\begin{minipage}{.9\linewidth}
  \captionof{algorithm}{from\_decimal\_recursion\label{alg:fromdecimalrecursion}}
  \begin{algorithmic}[1]
    \Require{$a$, big--integer, $b_{10}$ decimal string, $s$ start, $e$ end, given by from\_decimal}
    \Ensure{$a$ filled with the value of $b_{10}$ converted from a decimal number}
    \Function{from\_decimal\_recursion}{$a$,$b_{10}$, $s$, $e$}
    \Let{$\ell$}{$e - s$ }
    \If{$\ell < C$}\Comment{$C$ is the cut--off value from algorithm\ref{alg:fromdecimal}}
      \Let{$a$}{$b_{10} \to b_\beta$}\Comment{Convert the decimal number in $b_{10}$ from bytes $s$ to $e$ %
                                              to the bigint $a$.}
      \RETURN
    \Else
      \Let{$m$}{$\floor{\frac{\ell}{2}}$}
      \State \Call{from\_decimal\_recursion}{$A$, $b_{10}$, $s$, $s + m + 1$}
      \State \Call{from\_decimal\_recursion}{$B$, $b_{10}$, $s + m + 1$, $e$}
      \Let{$T$}{$10^{\ell - m - 1}$}\label{alg:fromdecimalrecursion:line:T}
      \Let{$a$}{$A \cdot T + B$}
    \EndIf
    \EndFunction
  \end{algorithmic}
\end{minipage}
\end{center}

\subsection{Extending to other bases}

The algorithms \ref{alg:fromdecimal} \smalltt{from\_decimal} and \ref{alg:fromdecimalrecursion} \smalltt{from\_decimal\_recursion} can be extended to all other bases with minimal effort.


\begin{center}
\begin{minipage}{.9\linewidth}
  \captionof{algorithm}{from\_string\label{alg:fromstring}}
  \begin{algorithmic}[1]
    \Require{$a$, big--integer, $b_r$, string, $r$, the base}
    \Ensure{$a$ filled with the value of $b_r$ converted from a number in base $r$}
    \Function{from\_string}{$a$}
    \If{$r < 2 \OR r > 64$}
       \RETURN {$\quad$error}
    \EndIf
    \Let{$\ell$}{$\#b_r$} \Comment{Number of bytes (characters) in the string}
    \If{The first character in $b_r$ is a minus--sign}
       \Let{$\ell$}{$\ell - 1$}
       \If{$\ell = 0$} \Comment{No digits following the minus--sign}
          \RETURN {$\quad$error}
       \EndIf
       \Let{$a$}{$-a$}
       \State{Strip the byte for the character representing the sign from $b_r$}
    \EndIf
    \If{$\ell < C$}\Comment{$C$ is a (tunable) cut--off value.}
      \Let{$a$}{$b_r \to b_\beta$}\Comment{Convert the number in $b_r$ to the bigint $a$.}
    \Else
      \State \Call{from\_string\_recursion}{$a$, $b_r$, $0$, $\ell$, $r$}
    \EndIf
    \EndFunction
  \end{algorithmic}
\end{minipage}
\end{center}

The changes needed for the recursion are also minimal.

\begin{center}
\begin{minipage}{.9\linewidth}
  \captionof{algorithm}{from\_string\_recursion\label{alg:fromstringrecursion}}
  \begin{algorithmic}[1]
    \Require{$a$, big--integer, $b_r$ decimal string, $s$ start, $e$ end, $r$, the base, given by from\_string}
    \Ensure{$a$ filled with the value of $b_r$ converted from a number of base $r$}
    \Function{from\_string\_recursion}{$a$,$b_r$, $s$, $e$, $r$}
    \Let{$\ell$}{$e - s$ }
    \If{$\ell < C$}\Comment{$C$ is the cut--off value from algorithm\ref{alg:fromstring}}
      \Let{$a$}{$b_r \to b_\beta$}\Comment{Convert the number in $b_r$ from bytes $s$ to $e$ %
                                              to the bigint $a$.}
      \RETURN
    \Else
      \Let{$m$}{$\floor{\frac{\ell}{2}}$}
      \State \Call{from\_string\_recursion}{$A$, $b_r$, $s$, $s + m + 1$, $r$}
      \State \Call{from\_string\_recursion}{$B$, $b_r$, $s + m + 1$, $e$, $r$}
      \Let{$T$}{$r^{\ell - m - 1}$}
      \Let{$a$}{$A \cdot T + B$}
    \EndIf
    \EndFunction
  \end{algorithmic}
\end{minipage}
\end{center}

\subsection{Partial string conversion}
Both recursive algorithms to convert a string to a big--integer need a method for the last mile, the actual conversion. This can be done with an already existing iterative algorithm. It would need a copy of the part of the string it is supposed to convert which would double the amount of memory needed for the input--string.
But with almost all checks and balances already done, all we need is the inner loop of the actual conversion.

\begin{center}
\begin{minipage}{.9\linewidth}
  \captionof{algorithm}{from\_string\_small\label{alg:fromstringsmall}}
  \begin{algorithmic}[1]
    \Require{$a$, big--integer, $b_r$ decimal string, $s$ start, $e$ end, $r$, the base}
    \Ensure{$a$ filled with the value of $b_r$ from byte $s$ to byte $e$ converted from a number of base $r$}
    \Function{from\_string\_small}{$a$,$b_r$, $s$, $e$, $r$}
    \For{character (byte) $c$ in $b_r$ from byte $s$ to byte $e$}
       \If{$c < 0x28$}\Comment{Rough check if we have a usable ASCII character}
          \RETURN {$\quad$ error}
       \EndIf
       \Let{$p$}{$c - 0x28$}\Comment{Make the position $p$ $0$--based to be able to use a table}
       \State \CommentMulti{ Here $t$ is a small table for fast character--value mapping}
       \Let{$v$}{$t_p$}
       \If{$v \ge base$} \Comment{Wrong character?}
          \RETURN {$\quad$ error}
       \EndIf
       \Let{$a$}{$a \cdot r + v$}
    \EndFor
    \EndFunction
  \end{algorithmic}
\end{minipage}
\end{center}





\end{document}
